// Generated by CoffeeScript 1.10.0
var ANIMATIONSPEED, NS, Polygon, Rectangle, SVG, TAGTOCLASS, TRAVEL, animateSVG, blocks, button, h, hh, i, j, k, l, overhang, polygonLength, rect, ref, ref1, spacing, w, ww, x, y;

NS = "http://www.w3.org/2000/svg";

SVG = document.createElementNS(NS, "svg");

SVG.id = 'svg';

SVG.setAttribute('version', '1.1');

SVG.setAttribute('width', '100mm');

SVG.setAttribute('height', '100mm');

SVG.setAttribute('viewBox', '-10 -10 600 600');

w = 25;

h = 10;

spacing = 0;

blocks = 22;

for (i = k = 0, ref = blocks; 0 <= ref ? k < ref : k > ref; i = 0 <= ref ? ++k : --k) {
  for (j = l = 0, ref1 = blocks; 0 <= ref1 ? l < ref1 : l > ref1; j = 0 <= ref1 ? ++l : --l) {
    rect = document.createElementNS(NS, 'rect');
    x = (w + spacing) * i;
    y = (w + spacing) * j;
    ww = w;
    hh = h;
    overhang = (w - h) / 2;
    if ((i + j) % 2 === 1) {
      x += w / 2 - h / 2;
      y -= overhang;
      ww = h;
      hh = w;
      if (j === 0) {
        y += overhang;
        hh -= overhang;
      } else if (j === blocks - 1) {
        hh -= overhang;
      }
    } else {
      if (i === 0) {
        x += overhang;
        ww -= overhang;
      } else if (i === blocks - 1) {
        ww -= overhang;
      }
    }
    rect.setAttribute('width', ww);
    rect.setAttribute('height', hh);
    rect.setAttribute('x', x);
    rect.setAttribute('y', y);
    rect.style.stroke = 'black';
    rect.style.strokeWidth = '1';
    rect.style.fill = 'none';
    SVG.appendChild(rect);
  }
}

document.body.appendChild(SVG);

button = document.createElement('button');

button.innerHTML = "Download";

button.style.display = 'block';

button.onclick = function() {
  return saveAs(new Blob([document.getElementById('svg').outerHTML], {
    type: "application/svg+xml"
  }), "download.svg");
};

document.body.appendChild(button);

polygonLength = function(poly) {
  var dist, lastPoint, len, m, p, ref2;
  lastPoint = poly.points[poly.points.length - 1];
  dist = 0;
  ref2 = poly.points;
  for (m = 0, len = ref2.length; m < len; m++) {
    p = ref2[m];
    dist += Math.sqrt(Math.pow(lastPoint.x - p.x, 2) + Math.pow(lastPoint.y - p.y, 2));
    lastPoint = p;
  }
  return dist;
};

ANIMATIONSPEED = 500;

TRAVEL = 100 / ANIMATIONSPEED;

Rectangle = (function() {
  function Rectangle(element1) {
    this.element = element1;
  }

  Rectangle.prototype.length = function() {
    return (this.element.width.baseVal.value + this.element.height.baseVal.value) * 2;
  };

  Rectangle.prototype.animate = function(delay) {
    var length, time;
    length = this.length();
    this.element.style.transition = this.element.style.WebkitTransition = 'none';
    this.element.style.strokeDasharray = length + ' ' + length;
    this.element.style.strokeDashoffset = length;
    this.element.getBoundingClientRect();
    time = length / ANIMATIONSPEED;
    this.element.style.transition = this.element.style.WebkitTransition = 'stroke-dashoffset ' + time + 's linear';
    this.element.style.transitionDelay = delay + 's';
    console.log("delay", delay);
    this.element.style.strokeDashoffset = '0';
    return time;
  };

  return Rectangle;

})();

Polygon = (function() {
  function Polygon(element1) {
    this.element = element1;
  }

  Polygon.prototype.length = function() {
    var dist, lastPoint, len, m, p, ref2;
    lastPoint = this.element.points[this.element.points.length - 1];
    dist = 0;
    ref2 = this.element.points;
    for (m = 0, len = ref2.length; m < len; m++) {
      p = ref2[m];
      dist += Math.sqrt(Math.pow(lastPoint.x - p.x, 2) + Math.pow(lastPoint.y - p.y, 2));
      lastPoint = p;
    }
    return dist;
  };

  Polygon.prototype.animate = function(delay) {
    var length, time;
    length = this.length();
    this.element.style.transition = this.element.style.WebkitTransition = 'none';
    this.element.style.strokeDasharray = length + ' ' + length;
    this.element.style.strokeDashoffset = length;
    this.element.getBoundingClientRect();
    time = length / ANIMATIONSPEED;
    this.element.style.transition = this.element.style.WebkitTransition = 'stroke-dashoffset ' + time + 's linear';
    this.element.style.transitionDelay = delay + 's';
    console.log("delay", delay);
    this.element.style.strokeDashoffset = '0';
    return time;
  };

  return Polygon;

})();

TAGTOCLASS = {
  'rect': Rectangle,
  'polygon': Polygon
};

animateSVG = function(svg, delay) {
  var child, element, len, m, ref2, time;
  if (delay == null) {
    delay = 0;
  }
  time = delay;
  ref2 = svg.children;
  for (m = 0, len = ref2.length; m < len; m++) {
    child = ref2[m];
    if (TAGTOCLASS[child.tagName]) {
      element = new TAGTOCLASS[child.tagName](child);
      time += element.animate(time) + TRAVEL;
    }
    time = animateSVG(child, time + TRAVEL);
  }
  if (delay === 0) {
    console.log(time);
  }
  return time;
};

//# sourceMappingURL=main.js.map
