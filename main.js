// Generated by CoffeeScript 1.10.0
var ANIMATIONSPEED, C, HEIGHT, I, Ic, NS, Polygon, Rchance, Rectangle, Rint, Rpick, SCALE, SVG, SVGcircle, SVGline, SVGrectangle, TAGTOCLASS, TRAVEL, WIDTH, animateSVG, button, generateBubbels, generateFancyGrid, generateGuides, triangular;

Rint = function(max, min) {
  if (max == null) {
    max = 1;
  }
  if (min == null) {
    min = 0;
  }
  return Math.floor(min + Math.random() * (max + 1 - min));
};

Rchance = function(percentage) {
  return Math.random() * 100 < percentage;
};

Rpick = function(list) {
  return list[int(list.length - 1)];
};

C = function(value, min, max) {
  if (value < min) {
    return min;
  }
  if (value > max) {
    return max;
  }
  return value;
};

I = function(value, max, targetMax) {
  return (value / max) * targetMax;
};

Ic = function(value, max, targetMax) {
  var clamped;
  clamped = C(value, 0, max);
  return I(clamped, max, targetMax);
};

NS = "http://www.w3.org/2000/svg";

SVG = document.createElementNS(NS, "svg");

SVG.id = 'svg';

SVG.setAttribute('version', '1.1');

WIDTH = 600;

HEIGHT = 300;

SCALE = 2;

SVG.setAttribute('width', (WIDTH / SCALE) + 'mm');

SVG.setAttribute('height', (HEIGHT / SCALE) + 'mm');

SVG.setAttribute('viewBox', '0 0 ' + WIDTH + ' ' + HEIGHT);

document.body.appendChild(SVG);

SVGline = function(x1, y1, x2, y2, svg) {
  var line;
  line = document.createElementNS(NS, 'line');
  line.setAttribute('x1', x1);
  line.setAttribute('y1', y1);
  line.setAttribute('x2', x2);
  line.setAttribute('y2', y2);
  line.style.stroke = 'black';
  line.style.strokeWidth = '1';
  line.style.fill = 'none';
  svg.appendChild(line);
  return line;
};

SVGrectangle = function(x, y, w, h, svg) {
  var rect;
  rect = document.createElementNS(NS, 'rect');
  rect.setAttribute('x', x);
  rect.setAttribute('y', y);
  rect.setAttribute('width', w);
  rect.setAttribute('height', h);
  rect.style.stroke = 'black';
  rect.style.strokeWidth = '1';
  rect.style.fill = 'none';
  svg.appendChild(rect);
  return rect;
};

SVGcircle = function(x, y, r, svg) {
  var circle;
  circle = document.createElementNS(NS, 'circle');
  circle.setAttribute('cx', x);
  circle.setAttribute('cy', y);
  circle.setAttribute('r', r);
  circle.style.stroke = 'black';
  circle.style.strokeWidth = '1';
  circle.style.fill = 'none';
  svg.appendChild(circle);
  return circle;
};

triangular = function(a, b, c) {
  var F, U;
  U = Math.random();
  F = (c - a) / (b - a);
  if (U <= F) {
    return a + Math.sqrt(U * (b - a) * (c - a));
  } else {
    return b - Math.sqrt((1 - U) * (b - a) * (b - c));
  }
};

generateBubbels = function() {
  var circle, count, graphStep, graphSteps, i, k, l, ref, results, x;
  graphStep = 10;
  graphSteps = WIDTH / graphStep;
  count = [];
  for (i = k = 0, ref = graphSteps; 0 <= ref ? k < ref : k > ref; i = 0 <= ref ? ++k : --k) {
    count[i] = 0;
  }
  results = [];
  for (i = l = 0; l < 5000; i = ++l) {
    x = triangular(0, 600, 0);
    count[parseInt(x / graphStep)] += 1;
    results.push(circle = SVGcircle(x, Rint(HEIGHT), 2, SVG));
  }
  return results;
};

generateFancyGrid = function() {
  var blocksX, blocksY, h, hh, i, j, k, overhang, rect, ref, results, spacing, w, ww, x, y;
  w = 5;
  h = 2;
  spacing = 0;
  blocksX = 120;
  blocksY = 60;
  overhang = (w - h) / 2;
  console.log("total calculated width", w * blocksX - overhang * 2 + (blocksX - 1) * spacing);
  console.log("total calculated height", w * blocksY - overhang * 2 + (blocksY - 1) * spacing);
  results = [];
  for (i = k = 0, ref = blocksX; 0 <= ref ? k < ref : k > ref; i = 0 <= ref ? ++k : --k) {
    results.push((function() {
      var l, ref1, results1;
      results1 = [];
      for (j = l = 0, ref1 = blocksY; 0 <= ref1 ? l < ref1 : l > ref1; j = 0 <= ref1 ? ++l : --l) {
        x = (w + spacing) * i - overhang;
        y = (w + spacing) * j;
        ww = w;
        hh = h;
        if ((i + j) % 2 === 1) {
          x += w / 2 - h / 2;
          y -= overhang;
          ww = h;
          hh = w;
          if (j === 0) {
            y += overhang;
            hh -= overhang;
          } else if (j === blocksY - 1) {
            hh -= overhang;
          }
        } else {
          if (i === 0) {
            x += overhang;
            ww -= overhang;
          } else if (i === blocksX - 1) {
            ww -= overhang;
          }
        }
        if (i === blocksX - 1 && j === blocksY - 1) {
          console.log("width", x + ww);
          console.log("height", y + hh);
        }
        rect = SVGrectangle(x, y, ww, hh, SVG);
        results1.push(rect.style.strokeWidth = '0.1');
      }
      return results1;
    })());
  }
  return results;
};


/* GUIDE RECTS */

generateGuides = function(text) {
  var k, l, line, results, x, y;
  if (text == null) {
    text = false;
  }
  for (x = k = 0; k <= 600; x = k += 10) {
    line = document.createElementNS(NS, 'line');
    line.setAttribute('x1', x);
    line.setAttribute('y1', 0);
    line.setAttribute('x2', x);
    line.setAttribute('y2', 300);
    line.style.stroke = x % 50 === 0 ? 'rgb(100,100,100)' : 'rgb(200,200,200)';
    line.style.strokeWidth = '1';
    line.style.fill = 'none';
    SVG.appendChild(line);
    if (text && x % 50 === 0) {
      line = document.createElementNS(NS, 'text');
      line.setAttribute('x', x);
      line.setAttribute('y', 10);
      line.textContent = x;
      line.style.fill = 'red';
      line.style.fontSize = '12';
      SVG.appendChild(line);
    }
  }
  results = [];
  for (y = l = 0; l <= 300; y = l += 10) {
    line = document.createElementNS(NS, 'line');
    line.setAttribute('x1', 0);
    line.setAttribute('y1', y);
    line.setAttribute('x2', 600);
    line.setAttribute('y2', y);
    line.style.stroke = y % 50 === 0 ? 'rgb(100,100,100)' : 'rgb(200,200,200)';
    line.style.strokeWidth = '1';
    line.style.fill = 'none';
    SVG.appendChild(line);
    if (text && y % 50 === 0) {
      line = document.createElementNS(NS, 'text');
      line.setAttribute('x', 10);
      line.setAttribute('y', y);
      line.textContent = y;
      line.style.fill = 'red';
      line.style.fontSize = '12';
      results.push(SVG.appendChild(line));
    } else {
      results.push(void 0);
    }
  }
  return results;
};

generateBubbels();

document.body.appendChild(SVG);

button = document.createElement('button');

button.innerHTML = "Download";

button.style.display = 'block';

button.onclick = function() {
  return saveAs(new Blob([document.getElementById('svg').outerHTML], {
    type: "application/svg+xml"
  }), "download.svg");
};

document.body.appendChild(button);

ANIMATIONSPEED = 500;

TRAVEL = 100 / ANIMATIONSPEED;

Rectangle = (function() {
  function Rectangle(element1) {
    this.element = element1;
  }

  Rectangle.prototype.length = function() {
    return (this.element.width.baseVal.value + this.element.height.baseVal.value) * 2;
  };

  Rectangle.prototype.animate = function(delay) {
    var length, time;
    length = this.length();
    this.element.style.transition = this.element.style.WebkitTransition = 'none';
    this.element.style.strokeDasharray = length + ' ' + length;
    this.element.style.strokeDashoffset = length;
    this.element.getBoundingClientRect();
    time = length / ANIMATIONSPEED;
    this.element.style.transition = this.element.style.WebkitTransition = 'stroke-dashoffset ' + time + 's linear';
    this.element.style.transitionDelay = delay + 's';
    console.log("delay", delay);
    this.element.style.strokeDashoffset = '0';
    return time;
  };

  return Rectangle;

})();

Polygon = (function() {
  function Polygon(element1) {
    this.element = element1;
  }

  Polygon.prototype.length = function() {
    var dist, k, lastPoint, len, p, ref;
    lastPoint = this.element.points[this.element.points.length - 1];
    dist = 0;
    ref = this.element.points;
    for (k = 0, len = ref.length; k < len; k++) {
      p = ref[k];
      dist += Math.sqrt(Math.pow(lastPoint.x - p.x, 2) + Math.pow(lastPoint.y - p.y, 2));
      lastPoint = p;
    }
    return dist;
  };

  Polygon.prototype.animate = function(delay) {
    var length, time;
    length = this.length();
    this.element.style.transition = this.element.style.WebkitTransition = 'none';
    this.element.style.strokeDasharray = length + ' ' + length;
    this.element.style.strokeDashoffset = length;
    this.element.getBoundingClientRect();
    time = length / ANIMATIONSPEED;
    this.element.style.transition = this.element.style.WebkitTransition = 'stroke-dashoffset ' + time + 's linear';
    this.element.style.transitionDelay = delay + 's';
    console.log("delay", delay);
    this.element.style.strokeDashoffset = '0';
    return time;
  };

  return Polygon;

})();

TAGTOCLASS = {
  'rect': Rectangle,
  'polygon': Polygon
};

animateSVG = function(svg, delay) {
  var child, element, k, len, ref, time;
  if (delay == null) {
    delay = 0;
  }
  time = delay;
  ref = svg.children;
  for (k = 0, len = ref.length; k < len; k++) {
    child = ref[k];
    if (TAGTOCLASS[child.tagName]) {
      element = new TAGTOCLASS[child.tagName](child);
      time += element.animate(time) + TRAVEL;
    }
    time = animateSVG(child, time + TRAVEL);
  }
  if (delay === 0) {
    console.log(time);
  }
  return time;
};
